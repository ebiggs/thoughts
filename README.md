thoughts
========

Monad the Ultimate!

Fans of functional programing have long held [lambda to be The Ultimate](http://lambda-the-ultimate.org). They were
right about lambda being the ultimate for computation. But they were wrong about it being the ultimate for computers.
This is because computers do more than compute. They also are instruments. A great example of how a computer is
an instrument is that it has a screen and a keyboard and mouse or touchscreen that humans use to interact with them, and 
they have wires and wireless networking capabilities so that they can interact with eachother ad hoc.
So they do a whole heck of a lot of computing, but they do more. And so lambda is almost the ultimate, but not quite.
Something else is, and that something, my friends, is The Monad!

How is Monad The Ultimate?

As an armchair physicist I'm aware that physics is hoping for a grand unifying theory i.e. string theory, etc. Physicists
are theoretical sorts of folks, so this idea of a grand unifying theory that encompasses their many schools is something
they eagerly await for with a sense of anticipition. I've found, though, that few programmers are the theoretical sort of
folks and instead look at theories such as lambda calculus, and monads with a sense of hesitation or confusion or
resistance. Which is really a shame because programmers use abstraction every day. They're abstractioners more than
they're programmers because abstraction is necessary to get real world stuff done. If they were sitting at their machines
writing assembly code they woludn't get done all the amazing things that they get done. They embrace abstraction, and
abstraction is fundamentally theoretical. Programmers might call this theory intuition or time and experience, but
they're really doing themselves a disservice in doing so. They've mastered theories through perseverence and patience
but some have avoided embracing this process. Even to the point that I see a huge trend in talking about monads in
non-theoretical terms, but rather in trying to gain an intuition and seeing where they've used them already, etc. These
are great, but they ought to be supplimented with theory, otherwise the beauty of monads isn't fully realized.

But let me back up. There are of course, lots of peolpe who love computer science theory. These people even have their
own languages, like Haskell. There are, in a sense, two schools. We can call these schools the Turing School and the
Church School. Before there was this ubiquitous access to computers there was computation. Turing liked to think about
computation by imagining the workings of a machine that was capable of computing. Alonso Church, on the other hand took
a more mathematical approach and developed Lambda Calculus to help him think about computation. Both were interesting
and equally powerfull ways in deciding computability, however some would argue that Church provided a superior formalism.
It allowed us to think and reason about computability in a way that was easier to abstract and reason about.

The Turing school has occupied more programmer mindshare. The reason for this is that it's proven to be so practical. 
Computers are machines that do more than compute, after all. When you embrace their machine nature you've traditionally
been able to get things done in a superior way - especailly in times when computers were just a fraction as powerful
as they are today. C is very close to the metal and C is everywhere. Linus Torvals wouldn't have gone too far had
he attempted to implement linux in, say lisp, or other languages that fell out of the lambda/Church school. Of course,
the best C programmers are aware of lisp and haskell and their code is better for it. They utilize that theory to write
code that's safer and easier to reason about.

So what we're going to see about the Monad is that it provides a bridge between the two schools. This should be readily
apparent just seeing the use cases that motivated the Monad. Monads come to us via the world of Haskell. They allowed
Haskell, an otherwise "pure" "lambda" type of language, to do more than just compute. They allowed a way to murge the
world of computers as an instrument into the world where lambda is the ultimate way of thinking about computation. They
are the grand unifying theory that can and probably will bring together the two schools in a post-divided world. The
future will not be divided. It will be a Turing/Church world with the Monad being the grand unifying theory.
